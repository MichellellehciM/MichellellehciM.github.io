[{"content":" Git 和 GitHub 的冷知識，你能回答得出幾個? Git 的作者是誰？\n(A) 一個英國黑客 (B) Linux 之父 (C) 微軟創辦人 GitHub 的吉祥物其實不是貓!?\nGitHub 的 404 頁面有神祕彩蛋\n你知道 Git 其實是很中二的命名方式嗎？\nGitHub 把全世界的程式碼 冷凍 起來了！這是怎麼回事？\n什麼是 Git？ Git 是一個「版本控制系統」。\n它的主要功能是在你的電腦上記錄、管理專案的所有修改歷史，就像為每一份檔案做備份。\n可以追蹤程式碼改了什麼、什麼時候改的、誰改的 每次改動都被記錄下來，一點都不會漏掉 不小心寫壞也不用怕，一鍵回到過去 把 Git 想像成「你自己電腦上的時光機」，可以隨時回到以前的版本。\n什麼是 GitHub？ GitHub 是一個「線上的程式碼託管平台」。\n它讓你可以把自己電腦上的 Git 專案「推送（push）」到網路上，\n方便多人協作、備份、開源分享。\n讓團隊成員一起開發專案 能線上審查（review）、討論、管理任務 就算電腦壞了，雲端也有備份 GitHub 像是「放你時光機記錄的所有版本的雲端資料庫」，你也能邀請朋友一起來看、一起改。\nGit 與 GitHub 的關係 Git GitHub 定位 版本控制工具（軟體） 雲端協作平台（網站、服務） 作用 追蹤/記錄本地檔案的所有變更 存放 Git 專案、多人協作與分享 使用地點 自己的電腦 網路（cloud） 需不需要網路 不一定，離線也能用 需要網路 互動方式 指令操作（git init, commit） 介面/網站操作，也有 API 例子 git commit, git status Pull request、Issue、Actions Git 負責管理你電腦上的程式碼歷史紀錄，GitHub 則是讓大家能在雲端一起同步、討論與展示這些變動。\n沒有 GitHub 也能用 Git，但團隊協作、遠端備份會很麻煩。 (就像你上課寫筆記，想要跟朋友共用、備份、共寫，就一定要放到雲端（比如 Google 雲端硬碟、Notion、GitHub）才能一起修改)\n其實還有 GitLab、Bitbucket 等其他雲端平台，但 GitHub 最有名。\n❓常見問題 Q\u0026amp;A Q1. GitHub 是不是等於 Git？ 不是！Git 是版本控制工具，GitHub 是雲端平台。你可以只學 Git，不用 GitHub；但用 GitHub 前一定要會 Git。\nQ2. 一定要用 GitHub 嗎？ 不用，可以選擇 GitLab、Bitbucket…等類似服務，甚至只用 Git 管理本地專案也沒問題。但現今多數開源和團隊專案都用 GitHub。\nQ3. 不會 Git 可以直接用 GitHub 嗎？ 不行。GitHub 的核心運作還是基於 Git 指令（commit、push、pull 等），所以要先懂 Git。\nQ4. 實際開發流程長怎樣？ 在本地用 Git 版本控制（init、add、commit） 用 GitHub 當「遠端倉庫」（push 上去，團隊 pull 下來一起改） 團隊協作、Code Review 都在 GitHub 平台完成 冷知識解答區 1. Git 的作者到底是誰？ 答案是 (B) Linux 之父 Linus Torvalds！\nLinus Torvalds（Linux 之父）原本是為了管理 Linux 核心原始碼才開發出 Git，他認為當時沒有免費且好用的版本控制工具，乾脆自己寫一套，他在 2005 年花了兩週寫出 Git。\n2. GitHub 的吉祥物其實不是貓!? 其實 Octocat 是一隻結合章魚（Octopus）和貓（Cat）的超可愛生物！想看所有 Octocat 的造型可以直接逛Octodex 官網。\n3. GitHub 的 404 頁面有彩蛋？ 沒錯~ 只要在瀏覽器進入一個不存在的 GitHub 網址，\n例如： github.com/this-page-does-not-exist\n404 頁面就會出現可愛的章魚貓，圖案經常變換，有時還能看到特殊主題（如節日、紀念日）限定插圖。\n4. 「Git」的名字很中二？ 真的，Linus 在剛釋出的 Git 的 README 檔案中寫道：\ngit 是隨便挑的發音簡單的三個字母，沒有特別意義。 git 在英文可指「蠢蛋」、「討人厭的傢伙」、「白癡」，你隨便從字典裡挑一個定義吧！ 如果心情好時，他會把 git 當成 \u0026ldquo;global information tracker\u0026rdquo; (全球訊息追蹤器)。 當 git 壞掉時，他會把 git 罵成 \u0026ldquo;goddamn idiotic truckload of sh*t\u0026rdquo; (一堆爛屎)。 git README 原文檔案\n5. GitHub 將全世界的 code 冷凍起來了？ 沒錯！GitHub 把所有2020 年 2 月 2 日前還 active 的開源專案，全部燒錄成 188 捲特製膠片，放在 北極程式碼庫（Arctic Code Vault）裡，希望能保存 1000 年。\n只要你的程式碼有被 GitHub 收錄進北極備份，GitHub 就會在你的個人頁面加上一個「Arctic Code Vault」徽章，代表你也是人類文明備份的一份子！\n總結 Git = 版本控制工具，讓你管理自己電腦上的程式碼歷史 GitHub = 雲端平台，讓你把 Git 專案放到網路上，方便備份、多人協作 Git 是基礎，GitHub 讓協作和分享變簡單 互動問題 你平常有備份檔案的習慣嗎？如果是團隊合作，怎麼確保大家都用同一份檔案？ 你覺得本地 Git 和雲端 GitHub 最大的差別是什麼？ 延伸閱讀 Git 官方教學 ","date":"2025-06-25T10:00:00Z","image":"https://michellellehcim.github.io/p/git-vs-github/git-github_hu11637304623576181919.png","permalink":"https://michellellehcim.github.io/p/git-vs-github/","title":"Git 和 GitHub 的差別？以及那些你不知道的冷知識！"},{"content":" 什麼是 API？ API（Application Programming Interface） 是「應用程式之間溝通的橋樑」。\n📦 比喻：\n你 = 使用者（前端） 店員 = API 廚房 = 後端邏輯/資料庫 你只需要點餐（呼叫 API），店員會幫你處理後台的事情，然後回你食物（資料）！\n(注意) API 不等於 REST，REST 是一種設計 API 的風格。\n什麼是 REST？ REST（REpresentational State Transfer） 是一種設計 API 的「規範」與「風格」，鼓勵使用「HTTP 方法 + 有語意的資源路徑（URL）」來操作資料。\nREST 的資源設計非常直覺，例如：\n/users/ 表示所有使用者 /users/1/ 表示 ID=1 的使用者 /posts/5/comments/ 表示第 5 篇貼文的留言 什麼是 RESTful API？ 當你設計的 API 遵循 REST 的風格，就可以稱它為 RESTful API。\n特徵： 路徑是「名詞」不是「動詞」 ✅ /users/1/（好） ❌ /getUserById?id=1（壞） 行為交給 HTTP 方法（GET、POST、PUT、DELETE） 每次請求都是獨立的（Stateless） 回傳 JSON 格式資料（通常） HTTP 方法與 REST API 對應表 功能 HTTP 方法 路徑範例 操作說明 查詢全部 GET /api/users/ 查詢所有使用者 查詢單筆 GET /api/users/1/ 查詢 ID=1 的使用者 新增資料 POST /api/users/ 建立新使用者 完整更新 PUT /api/users/1/ 完全覆蓋使用者資料 局部更新 PATCH /api/users/1/ 只更新部分欄位 刪除資料 DELETE /api/users/1/ 刪除該使用者 REST 的核心設計原則簡化版 原則名稱 白話說明 Client-Server 前後端分離，分工明確 Stateless 每次請求都自帶資料，伺服器不會記住你 Cacheable 可以快取的 API 要能標示出來 Uniform Interface 使用統一的 URL + 方法設計資源（核心） Layered System 前端不需知道後端架構幾層 Code on Demand 可選：伺服器可以傳 JS 給前端執行（較少用） Django REST API 對照範例 ✅ 傳統 Django 表單方式 1 2 3 4 5 6 @require_POST def create_user(request): form = UserForm(request.POST) # 從表單 POST 資料建立表單實例 if form.is_valid(): # 驗證欄位是否合法 form.save() # 寫入資料庫 return redirect(\u0026#34;users:index\u0026#34;) # 成功後重新導向到其他頁面 ✅ RESTful API（使用 Django REST Framework） 1 2 3 4 5 6 @api_view([\u0026#34;POST\u0026#34;]) def create_user(request): serializer = UserSerializer(data=request.data) # 從 JSON 資料建立序列化器 if serializer.is_valid(): # 驗證資料格式與規則 serializer.save() # 將資料存入資料庫 return Response(serializer.data, status=201) # 回傳 JSON 資料與 HTTP 狀態碼 新手常見問題 Q\u0026amp;A Q1：RESTful API 一定要用 JSON 嗎？ 不是一定要，但 JSON 是最常見、跨平台友善、前端也好處理的格式。\nQ2：REST 是一種技術嗎？ 不是，它是 API 的設計「風格」，不是一種程式語言或框架。\nQ3：HTTP 是 REST 的一部分嗎？ 不是從屬關係，REST 通常是用 HTTP 實作而成。\nQ4：什麼是副作用？為什麼要避免在 GET 中發生？ 副作用是指「會改變資料或狀態的行為」，例如新增、刪除或更新資料。REST 規範建議 GET 請求只能讀取資料，若 GET 執行寫入或刪除，可能導致安全風險與重複操作問題。\nQ5：RESTful API 的命名方式有什麼好處？ 使用資源導向的 URL（如 /users/1/）搭配 HTTP 方法，可以讓 API 結構一致、語意清楚，利於維護與團隊溝通，也方便前端或第三方串接理解行為。\n總結 RESTful API 是一種讓前後端（或服務與服務之間）能夠透過 HTTP 協定交換資料的設計風格。 它通常用 JSON 傳輸資料，搭配像 GET / POST / PUT / DELETE 等標準 HTTP 方法，簡潔、清楚、可擴充。\n名詞 定義 API 應用程式之間的溝通橋樑 REST 設計 API 的風格與原則 RESTful API 遵循 REST 原則設計的 API HTTP 方法 操作 API 所用的語法（如 GET、POST） 💬 腦力激盪：你學會了嗎？ 你覺得哪一個 URL 設計比較符合 REST 原則？\nA. /getUserById?id=3 B. /users/3/ 如果要刪除 ID 為 10 的留言，你會：\nA. 用 POST /deleteComment/10 B. 用 DELETE /comments/10/ 歡迎留言你的答案，讓我們一起練習！\n(答案)\n正確選項 原因說明 1 B. /users/3/ RESTful 設計強調「資源導向」，應以名詞 /users/ 表示資源，以 /3/ 表示具體某個實體，不應使用動詞如 getUserById 2 B. DELETE /comments/10/ RESTful API 應使用 HTTP 方法語意表達動作，如刪除操作就使用 DELETE，不應用 POST + 動詞路徑去模擬 END\n","date":"2025-06-20T10:00:00+08:00","image":"https://michellellehcim.github.io/p/what-is-restful-api/restful_api_guide_hu5184701980988772211.png","permalink":"https://michellellehcim.github.io/p/what-is-restful-api/","title":"什麼是 API、REST、RESTful API？一次搞懂概念與實作原則"},{"content":"\r🧠 Merge Two Sorted Linked Lists：新手圖解指南 🔍 題目說明 你會得到兩個已排序的 Linked List：\n1 2 list1 = 1 -\u0026gt; 2 -\u0026gt; 4 list2 = 1 -\u0026gt; 3 -\u0026gt; 4 請你將它們合一為一條新的排序 list，但要直接拼接節點（in-place），不能創建新節點。\n✅ 什麼是 dummy = ListNode()？ 這是一個技巧：建立一個虛擬節點，作為拼接過程的起點，方便統一管理，不用特別處理第一個節點。\n1 2 dummy = ListNode() current = dummy dummy 幫你記住整條 list 的起點 current 是指針，責任接新節點 🎨 Mermaid 圖示教學（支援 HTML 模式） 📌 初始狀態：建立 dummy 和 current graph LR\rA((dummy)) --\u003e B(None)\rA -.-\u003e C((current))\r🔁 過程中：逐步拼接節點 graph LR\rA((dummy)) --\u003e B(1) --\u003e C(1) --\u003e D(2) --\u003e E(3)\rE -.-\u003e F((current))\r每次比較 list1 和 list2 的頭 current.next = 比較小的節點 current 指針後移一格 ✅ 最終結果：回傳 dummy.next graph LR\rA((dummy)) --\u003e B(1) --\u003e C(1) --\u003e D(2) --\u003e E(3) --\u003e F(4) --\u003e G(4)\rstyle A fill:#eee,stroke:#aaa,stroke-width:2px\r你不會回傳 dummy 本身 最終結果是 dummy.next dummy 是工具人，拼完就功成身退 🧹 💡 小結 名稱 用途 dummy 虛擬開頭節點，固定整條 list 的起點 current 指向目前要拼接的節點 dummy.next 最終拼好的 list 開頭 🌟 現在你已經應該能自己畫出 linked list 的合併過程了！\n","date":"2025-05-27T10:00:00Z","image":"https://michellellehcim.github.io/linked-list.png","permalink":"https://michellellehcim.github.io/p/linked-list/","title":"Merge Two Sorted Linked Lists：新手圖解指南"},{"content":" 什麼是多型？ **多型（Polymorphism）**是物件導向程式設計的四大特性之一，不同的類別可以使用相同的方法名稱，但根據對象不同，執行的行為也不同。\n例如：speak( ) 在 Dog 是\u0026quot;汪\u0026quot;，在 Cat 是\u0026quot;喵\u0026quot;。\n多型的優點 優點 說明 介面統一 不管是哪一個子類別，使用者都用相同方法呼叫，提升一致性。 可擴充性高 新增類別（例如 ApplePay）不用改原本邏輯，只要繼承並實作介面即可。 維護性高 改變其中一個子類別的實作，不影響其他類別與主流程。 搭配抽象類別使用 搭配 ABC 實作，可以強制子類別遵守規範，避免遺漏必要方法。 多型的幾種常見用法 繼承 + 方法覆寫（Override） 抽象類別（Abstract Class） ← 若不熟建議先閱讀前一篇教學 鴨子型別（Duck Typing） 內建函式多型（如 len） 範例一：繼承與方法覆寫 最常見的方式：透過繼承父類別，並在子類別中重新定義方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Animal: def speak(self): print(\u0026#34;不知道怎麼叫\u0026#34;) class Dog(Animal): def speak(self): print(\u0026#34;汪！\u0026#34;) class Cat(Animal): def speak(self): print(\u0026#34;喵！\u0026#34;) animals = [Dog(), Cat()] for a in animals: a.speak() # 汪! # 喵! 說明： 雖然呼叫的都是 speak()，但根據物件型別（Dog or Cat），會自動選擇正確的方法來執行。\n範例二：搭配抽象類別（Abstract Class） 用 abc 模組強制每個子類別都要實作某些方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from abc import ABC, abstractmethod class Payment(ABC): @abstractmethod def pay(self, amount): pass class CreditCard(Payment): def pay(self, amount): print(f\u0026#34;信用卡支付 {amount} 元\u0026#34;) class LinePay(Payment): def pay(self, amount): print(f\u0026#34;LinePay 支付 {amount} 元\u0026#34;) def process_payment(method: Payment, amount): method.pay(amount) # Payment 是 型別提示（Type Hint） # 這裡的 method 是你傳進來的物件參數，它代表一個「支付方法的物件」，可能是：CreditCard() 的物件、LinePay() 的物件、任何有 .pay() 方法的物件 process_payment(CreditCard(), 100) # 信用卡支付 100 元 process_payment(LinePay(), 200) # LinePay 支付 200 元 主程式只關心介面（pay），不管是信用卡還是行動支付，通通能通用。\n範例三：鴨子型別（Duck Typing） 彈性高，不需繼承自共同父類別，適合快速開發與原型設計。\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Duck: def quack(self): print(\u0026#34;呱呱！\u0026#34;) class Person: def quack(self): print(\u0026#34;我模仿鴨子：呱呱～\u0026#34;) def make_it_quack(obj): obj.quack() make_it_quack(Duck()) # 呱呱！ make_it_quack(Person()) # 我模仿鴨子：呱呱～ 這就是所謂的「If it quacks like a duck, it\u0026rsquo;s a duck.」—— 不看你是不是鴨子，看你會不會 quack。\n範例四：內建函式多型（如 len） 像 len( ) 就是多型的例子，它能對字串、列表、字典\u0026hellip; 都使用。\n1 2 3 print(len(\u0026#34;hello\u0026#34;)) # 5 print(len([1, 2, 3])) # 3 print(len({\u0026#34;a\u0026#34;: 1})) # 1 腦力激盪 假設你正在開發一個通知系統，包含 Email、Line、SMS，你會怎麼設計？會怎麼運用多型？歡迎留言討論！\n(參考答案)\n通知系統的多型設計範例 : 定義一個統一介面 send(message)，不管是 Email、Line 或 SMS，都要實作這個方法。\n(1) 抽象類別：Notifier\n1 2 3 4 5 6 from abc import ABC, abstractmethod class Notifier(ABC): @abstractmethod def send(self, message): pass (2) 子類別實作：Email、Line、SMS\n1 2 3 4 5 6 7 8 9 10 11 class EmailNotifier(Notifier): def send(self, message): print(f\u0026#34;寄送 Email：{message}\u0026#34;) class LineNotifier(Notifier): def send(self, message): print(f\u0026#34;發送 Line 訊息：{message}\u0026#34;) class SMSNotifier(Notifier): def send(self, message): print(f\u0026#34;傳送簡訊：{message}\u0026#34;) (3) 使用多型處理通知\n1 2 3 4 5 6 7 def notify_user(notifier: Notifier, message: str): notifier.send(message) # 測試 notify_user(EmailNotifier(), \u0026#34;歡迎使用我們的服務\u0026#34;) notify_user(LineNotifier(), \u0026#34;您的驗證碼是 1234\u0026#34;) notify_user(SMSNotifier(), \u0026#34;付款成功，感謝您的支持\u0026#34;) ","date":"2025-05-27T10:00:00Z","image":"https://michellellehcim.github.io/p/python-polymorphism-guide/python_polymorphism_guide_hu9827913951195154838.png","permalink":"https://michellellehcim.github.io/p/python-polymorphism-guide/","title":"Python OOP入門指南 (四) ：多型"},{"content":" 抽象類別是什麼？ 抽象類別（Abstract Class） 是一種 無法被直接實例化 的類別，它的主要用途是作為「模板」提供一套明確的設計規範，讓子類別去實作必要的方法。\n簡單來說，抽象就是隱藏不必要的細節，保留對使用者有意義的部分。\n想像你在便利商店點飲料，你只會按下「冰美式」，不會去控制水溫、豆量、壓力值。咖啡機幫你包辦了背後的複雜程序，而你只需要操作「make_drink()」這個介面。\n抽象讓你只看見「你需要的操作」，不被內部細節干擾。\n抽象類別的三大特性： 不能直接建立實例 包含一個或多個抽象方法 子類別必須實作所有抽象方法才能使用 抽象類別像是一份“介面契約”，強迫所有子類別遵守這份規定，避免遺漏必要功能。\n為什麼要使用抽象類別？ 優點 說明 統一規範 強制子類別都實作特定方法，確保一致性 易於擴充 子類別的功能結構清晰，不易出錯 避免遺漏 每位開發者知道該實作哪些方法 適合團隊合作 明確開發規範，合作更順暢 Python 如何實作抽象類別？ Python 並不像 Java、C++ 內建 abstract 關鍵字，而是透過內建模組 abc（Abstract Base Class）來達成。\n建立抽象類別的三步驟 : 第一步：匯入模組 1 2 import abc from abc import ABC, abstractmethod # ABC 是內建的抽象類別基底類別 可不要覺得 ABC 是因為人家懶得想名字而隨便取的唷 只是簡寫真的剛好是ABC~\nabc = 模組名稱 ABC = Abstract Base Classes (模組基底類別) @abstractmethod = 用來定義抽象方法的裝飾器\n第二步：定義抽象類別與抽象方法 1 2 3 4 class Animal(ABC): # 繼承 ABC 成為抽象類別 @abstractmethod def make_sound(self): # 抽象方法，沒有實作內容 pass 第三步：由子類別實作抽象方法 1 2 3 4 5 6 7 class Dog(Animal): def make_sound(self): # 必須實作父類別的抽象方法 print(\u0026#34;汪汪！\u0026#34;) class Cat(Animal): def make_sound(self): print(\u0026#34;喵喵！\u0026#34;) 一旦類別中包含 @abstractmethod 方法，該類別就不能被實例化。 它會標記一個方法為「抽象」，代表這個方法在父類別中不提供實作細節，而是留給子類別自行定義。\n如果子類別沒有實作所有抽象方法，將無法建立該類別的實例，會拋出 TypeError。(看下方範例)\n1 2 3 4 5 6 class Dog(Animal): def make_sound(self): print(\u0026#34;汪汪\u0026#34;) # 有實作 ✔️ d = Dog() # 建立實例 d.make_sound() # 汪汪 1 2 3 4 5 class Dog(Animal): def make_sound(self): pass # ❌ 雖然語法正確，但沒有實際內容，視為未實作 # d = Dog() ❌ TypeError: Can\u0026#39;t instantiate abstract class Dog with abstract method make_sound ✅ 完整範例：動物叫聲系統 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from abc import ABC, abstractmethod # 抽象類別 class Animal(ABC): @abstractmethod def make_sound(self): pass def sleep(self): print(\u0026#34;Zzz...\u0026#34;) # 抽象類別也可有一般方法 # 子類別實作 class Dog(Animal): def make_sound(self): print(\u0026#34;汪汪！\u0026#34;) class Cat(Animal): def make_sound(self): print(\u0026#34;喵喵！\u0026#34;) # a = Animal() # ❌ TypeError：無法建立抽象類別的實例 d = Dog() d.make_sound() # 汪汪！ d.sleep() # Zzz... 💬 常見問題 Q\u0026amp;A Q1: 抽象和封裝有什麼不同？ 抽象是隱藏實作行為、只對外提供接口；封裝是保護資料不被任意存取。\nQ2：一定要用 ABC 嗎？ 是的，繼承 ABC 或使用 metaclass = ABCMeta 是 Python 抽象類別的必要設定。\n1 2 3 4 5 # 另一種寫法 class Animal(metaclass=abc.ABCMeta): @abc.abstractmethod def make_sound(self): pass Q3：如果子類別沒有實作抽象方法會怎樣？ 會在建立子類別實例時拋出 TypeError，提醒你沒有實作必要的方法。 (↑看上面動物叫聲系統範例)\nQ4：抽象類別可以包含普通方法嗎？ 可以。除了抽象方法，也可以寫一般方法，提供子類別共用的功能。\n1 2 3 4 5 6 7 class Animal(ABC): @abstractmethod def make_sound(self): # 抽象方法 pass # 沒有實作內容，只是一個規範接口 def sleep(self): # 一般方法 print(\u0026#34;Zzz...\u0026#34;) Q5：抽象類別可以加屬性嗎？ 可以，但建議放共用或初始化用的屬性，具體邏輯留給子類別處理。\nQ6：什麼時候應該使用抽象類別？ 當你希望每個子類別都遵守統一規則或結構（如：付款、載具、通知類別）。\nQ7：ABC 是什麼？和 metaclass=ABCMeta 有什麼關係？ ABC 就是 metaclass=ABCMeta 的語法糖（syntactic sugar）。 寫 class A(ABC): 的效果等同於 class A(metaclass=ABCMeta)。 這樣寫更簡潔可讀，也更常見\n💡 延伸補充：metaclass 是什麼？ 在 Python 中，一切皆物件，類別也是一種物件，它的類型就是 type。\n1 2 3 4 class Product: pass print(type(Product)) # \u0026lt;class \u0026#39;type\u0026#39;\u0026gt; 也就是說：\nProduct 是一個類別（class）\n但它本身也是一個物件\n它是由 type 類別創造出來的物件（也就是 Python 中預設的 metaclass）\n1 2 3 4 5 6 from abc import ABC, abstractmethod class Animal(ABC): # 背後其實是 metaclass=ABCMeta @abstractmethod def make_sound(self): pass 當你使用 metaclass=ABCMeta，就是告訴 Python 使用一個特別的類型（MetaClass）來定義這個類別，使其具備「抽象類別」的行為。\n總結：建立抽象類別 3 步驟 1️⃣ from abc import ABC, abstractmethod 2️⃣ class 類別名(ABC): 3️⃣ 用 @abstractmethod 抽象類別是一種讓程式設計更有「架構」的利器，特別適合用在大型專案或多人開發時統一規格。\n🤔 腦力激盪 - 支付模組設計 假設你正在寫一個支付模組（Payment），有哪些方法應該是抽象的？你會怎麼實作 CreditCard、LinePay、街口支付 等子類別？\n(參考答案)\n(1) 我們可以先定義一個抽象基底類別 Payment，所有支付方式都要遵守以下統一接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from abc import ABC, abstractmethod class Payment(ABC): @abstractmethod def authorize(self, amount): \u0026#34;\u0026#34;\u0026#34;驗證是否可以付款，例如檢查餘額或授權碼\u0026#34;\u0026#34;\u0026#34; pass @abstractmethod def pay(self, amount): \u0026#34;\u0026#34;\u0026#34;執行實際付款邏輯\u0026#34;\u0026#34;\u0026#34; pass @abstractmethod def refund(self, amount): \u0026#34;\u0026#34;\u0026#34;退款流程\u0026#34;\u0026#34;\u0026#34; pass (2) 子類別實作 (CreditCard 信用卡支付 、 LinePay 、 街口支付)\n1 2 3 4 5 6 7 8 9 class CreditCard(Payment): def authorize(self, amount): print(f\u0026#34;信用卡授權 {amount} 元通過\u0026#34;) def pay(self, amount): print(f\u0026#34;已用信用卡付款 {amount} 元\u0026#34;) def refund(self, amount): print(f\u0026#34;已退還信用卡款項 {amount} 元\u0026#34;) 1 2 3 4 5 6 7 8 9 class LinePay(Payment): def authorize(self, amount): print(f\u0026#34;LinePay 授權成功，金額：{amount}\u0026#34;) def pay(self, amount): print(f\u0026#34;LinePay 完成付款 {amount} 元\u0026#34;) def refund(self, amount): print(f\u0026#34;LinePay 退款 {amount} 元成功\u0026#34;) 1 2 3 4 5 6 7 8 9 class JKOPay(Payment): def authorize(self, amount): print(f\u0026#34;街口支付已授權 {amount} 元\u0026#34;) def pay(self, amount): print(f\u0026#34;街口支付完成付款 {amount} 元\u0026#34;) def refund(self, amount): print(f\u0026#34;街口支付已完成退款 {amount} 元\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def process_payment(method: Payment, amount: int): method.authorize(amount) method.pay(amount) method.refund(amount) process_payment(CreditCard(), 500) process_payment(LinePay(), 800) # 信用卡授權 500 元通過 # 已用信用卡付款 500 元 # 已退還信用卡款項 500 元 # LinePay 授權成功，金額：800 # LinePay 完成付款 800 元 # LinePay 退款 800 元成功 以上實作包含了OOP中抽象和多型的應用：\n抽象（Abstraction） 是為了建立統一的介面，像 authorize()、pay()、refund()。\n多型（Polymorphism） 則是利用這個介面，讓不同子類（如 CreditCard, LinePay）在 不改變函式 process_payment() 寫法的前提下實現不同的行為。\n下個章節會帶大家更了解OOP的多型! 請拭目以待~\n","date":"2025-05-26T10:00:00Z","image":"https://michellellehcim.github.io/p/python-abstract-class-guide/python_abc_guide_hu15110077466231422676.png","permalink":"https://michellellehcim.github.io/p/python-abstract-class-guide/","title":"Python OOP入門指南 (二) ：抽象  掌握 ABC 與 @abstractmethod"},{"content":" 什麼是封裝（Encapsulation）？ 封裝的目的是將資料（属性）與操作資料的方法（函式）包在一起，隱藏內部實作細節、只露出必要介面供外部使用者座使用。是一種防止外不去呼叫存取內部實作細節的手段。\n就像你有一個銀行帳戶，不能讓別人直接改寫餘額，而是必須經由“安全的操作方法”來進行。\n封裝的重要性 提高安全性： 將屬性設為私有（private），讓外部不能直接改動，只能透過特定方法（Getter / Setter）來間接操作，防止不當存取與資料錯誤。\n方便維護與修改：\n封裝後就算內部實作有更改，只要對外的介面（方法）不變，使用者的程式碼就不用跟著改，這樣可大大提高程式的穩定性與相容性。\n降低耦合（Coupling）：\n外部不需要知道內部實作細節，只需使用提供的接口，模組間彼此獨立，能降低錯誤傳染風險。\n增加內聚（Cohesion）：\n同一個類別裡的屬性和方法都是相關的，將功能集中在一起，就不會雜亂無章。這樣讓類別更清楚、更有組織性。\n更容易除錯和測試：\n將狀態變數藏起來，錯誤發生時可追蹤到特定的操作流程，更容易發現錯誤問題點。\n支持抽象化思考：\n封裝配合繼承與多型，使得開發者可以只專注於 這個類別能「做什麼」而不是「怎麼做」。\n如何在 Python 中實現封裝？ Python 沒有像 Java 那樣明確的 private / protected 關鍵字，但透過「命名規則」與「裝飾器」也能達到相同效果。\n在了解真正實現封裝前，我們先來看一下 Python 中有哪些屬性存取層級。\n公開到私有層級介紹 1. 公開屬性 (public) 1 2 3 4 5 6 7 class Person: def __init__(self): self.name = \u0026#34;小明\u0026#34; # 公開屬性 p = Person() print(p.name) # 可讀 p.name = \u0026#34;小美\u0026#34; # 可改 一般的寫法無法實現封裝，因為任何人都可以自由讀寫修改。\n2. 受到保護的 protected ( _變數名稱 前面加單底線) (雖然之前已經寫過文章詳細說明底線(underscore)用法了，但還是幫大家再複習一下)\n1 2 3 4 5 6 class Employee: def __init__(self): self._salary = 30000 # Protected 屬性 e = Employee() print(e._salary) # ⚠️ 可以讀，但通常會建議讓內部使用 單底線是 Python 的約定俗成，意思是\u0026quot;建議不要外部直接使用\u0026quot;，但不是強制。 （只是約定，不是真正保護）\n3. 私有屬性 Private (__變數名稱 前面加雙底線) 外部無法直接存取，會經過名稱改寫（name mangling）。\n1 2 3 4 5 6 7 8 9 10 class BankAccount: def __init__(self): self.__balance = 1000 # 私有屬性 acc = BankAccount() print(acc.__balance) # ❌ AttributeError # 因為實際上變成了 _BankAccount__balance： print(acc._BankAccount__balance) # 可存取（但沒事不要這樣做） 雙底線代表私有屬性，__變數名 會被轉換成 _類別名__變數名，理論上使用_類別名__變數名可以被存取，但原則上不要直接存取。\n封裝用 Getter 和 Setter 方法 如果你想實現真正的封裝，且無法讓外部直接改動屬性，我們可以使用 Getter 和 Setter 方法來達成。\n🔹 Getter 是什麼？ 「讀取私有屬性」的方法，搭配 @property 裝飾器。\n目的是\u0026quot;想讓使用者像操作變數一樣簡單，但又希望在背後加上邏輯限制或驗證條件\u0026quot;。\n🔹 Setter 是什麼？ 「設定私有屬性」的方法，搭配 @變數.setter裝飾器。\n可以加入條件判斷，例如不接受負值，或自動做格式檢查。\n封裝範例-提款卡操作帳戶（簡單版） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class BankAccount: def __init__(self): self.__balance = 1000 # 私有屬性 @property def balance(self): # Getter：讀取餘額 return self.__balance @balance.setter def balance(self, value): # Setter：設定餘額（+ if條件） if value \u0026gt;= 0: self.__balance = value else: print(\u0026#34;餘額不能是負數！\u0026#34;) acc = BankAccount() # 設定 __balance = 1000（初始化） print(acc.balance) # 1000 acc.balance = 2000 # 觸發 @balance.setter()，修改成 2000 acc.balance = -999 # ❌ 錯誤訊息:餘額不能是負數！ 你可以這樣理解：\n1 2 value = acc.balance # 看起來像取值，其實是呼叫 getter acc.balance = 1000 # 看起來像賦值，其實是呼叫 settersetter(1000) 封裝範例延伸- 加入帳戶擁有者（進階版） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class BankAccount: def __init__(self, owner, balance): self.owner = owner self.__balance = balance # 私有屬性 @property def balance(self): return self.__balance @balance.setter def balance(self, value): if value \u0026gt;= 0: self.__balance = value else: print(\u0026#34;餘額不能是負數！\u0026#34;) account = BankAccount(\u0026#34;小美\u0026#34;, 500) # 建立帳戶並設定初始餘額 print(account.balance) # 500 account.balance = 800 # 觸發 @balance.setter() 設定新餘額 800 print(account.balance) # 800 account.balance = -100 # ❌ 嘗試設負數，顯示錯誤 總結 寫法 可見性 推薦用途 self.name public 完全公開，可隨意存取與修改 self._salary protected 半封裝，用於內部提示 self.__balance private 真正封裝，只能透過方法或屬性存取 @property 間接讀取 控控制讀取方式，可加入驗證邏輯 @setter 間接寫入 控制修改方式，可設定限制或保護資料 ❓常見問題 Q\u0026amp;A Q1: 雙底線 __ 是絕對私有嗎？ A: 並不是。它其實會被 Python 自動轉換成 _類別名__變數名，可以存取但通常不會這樣做，應視為私有。\nQ2: 什麼時候適合用封裝？ A: 當資料是關鍵、敏感或容易錯誤時，封裝能幫助你減少錯誤、提高程式可維護性，是寫好程式、好維護程式的基礎。\nQ3: @property 和 @setter 是語法糖嗎？ A: 是的，它們是語法糖。表面看起來像在存取或賦值變數，但實際上是在執行函式（方法）。這樣能讓程式碼更直覺、可讀性更高，同時仍保留封裝與邏輯驗證的能力。\n🤔 腦力激盪 假設你有一個 Student 類別，裡面有成績 score 屬性，你會不會想用封裝來保護它？為什麼？歡迎留言告訴我你的想法！\n(參考答案)\n會。 會選擇用封裝保護 score 屬性，因為成績是比較敏感的資料，如果沒有控制，可能會被亂設成負數或超過滿分，影響資料正確性。 透過 @property 和 @setter，我可以限制成績範圍只能在 0 到 100 之間，也方便之後要做成績加權或轉換等邏輯。\n","date":"2025-05-25T14:00:00Z","image":"https://michellellehcim.github.io/p/python-encapsulation-guide/python_encapsulation_hu687317837017193286.png","permalink":"https://michellellehcim.github.io/p/python-encapsulation-guide/","title":"Python OOP入門指南 (三) ：封裝"},{"content":" 什麼是繼承？ 繼承是物件導向中的一個重要概念。簡單來說：\n子類別（子 class）可以擁有父類別的屬性（Attribute）和方法（Method），不用重新寫一遍。 就像你從父母那裏繼承了身高、髮色，甚至壞習慣（？）\n在開始介紹繼承前，我們先來看一下這段程式碼:\n1 2 3 4 5 6 class Product: def __init__(self, name, price): self.name = name # 將傳入的 name 存成物件的屬性 self.price = price Product(\u0026#34;果汁\u0026#34;, 30) # 建立物件時，會自動執行 __init__() 方法。 什麼是 init( )？為什麼每個類別都有它？ 你可以把 init( ) 想像成「物件的出生設定」，它會自動幫你設定這個物件的「初始狀態」，例如名稱、價格等等。物件一創出生時，這個方法就會自動被執行，設定好初始資料。\ninit( ) 有一個專業術語叫 \u0026ldquo;constructor （建構子\u0026rdquo;） : 這是用來初始化物件、在物件「出生」的那一刻就自動執行。\n為什麼需要 constructor（建構子）？ 1 2 3 4 # 如果沒有 __init__() p = Product() p.name = \u0026#34;果汁\u0026#34; # 就得手動幫每個物件設定屬性 p.price = 30 1 2 # 但使用 __init__() p = Product(\u0026#34;果汁\u0026#34;, 30) # 只要一句話就完成 什麼是self？ self 指的是「目前這個物件本身」。就像你在介紹自己：「我的名字是 self.name」，這樣每個物件就能記住自己的資料。\n小結: init 是 對物件進行初始化 的特殊方法（constructor）。 self 是 物件本身，指的是這個 class 所建立出來的物件。 介紹完了__init__和self, 我們就可以來寫繼承了:\n首先，繼承的基礎寫法為 class 子(父) ， 代表子繼承父的屬性及方法。\n繼承 (基礎寫法): 1 2 3 4 5 6 7 8 9 class Product: # 先創建一個Product類別 def __init__(self, name, price): # 這是創建物件時會裝入的初始化功能 self.name = name # self.屬性name self.price = price # self.屬性price class Drink(Product): # (子)繼承(父) def __init__(self, name, price, volume): Product.__init__(self, name, price) # (1) self.volume = volume # (2) 這裡我們做了幾件事 : (1)「手動」呼叫父類別 Product 的 init( )，來初始化 name 和 price，然後再 (2) 自己新增 volume。\n我們來看這一句 :\n1 Product.__init__(self, name, price) # 呼叫父類別的 __init__方法 (父類別名稱).init(self,\u0026hellip;) 這種寫法看似沒什麼問題，但會有幾個缺點：\n如果未來父類別名稱改變，這裡也必要跟著一起改 → 維護困難。\n若有多重繼承（萬一同時繼承多個父類別）會搞混。\n為了解決上述問題，Python 提供了 super( ) 內建函式：\n什麼是 super( )？ super( ) 用來從子類別中呼叫父類別的方法。super( ) 代表的是「父類別」，但不用寫死父類別的名字。\n1 2 3 4 5 # ✅ 推薦寫法（更安全、彈性高、支援多重繼承） super().__init__(name, price) # 不推薦寫法（不夠彈性、父類別名稱寫死，未來難改） Product.__init__(self, name, price) 所以我們可以這樣寫\n繼承 (進階寫法) 1 2 3 4 class Drink(Product): def __init__(self, name, price, volume): super().__init__(name, price) # 呼叫父類別的 __init__ self.volume = volume 如果你未來把 Product 改名成 Item ， 用 super( ) 就不需要手動修改任何東西。\n小結: 當你想在「原本功能不變」的基礎上加一點自己的功能，就用 super() 把父類的東西也一起執行。\n總結： 概念 解釋 init() 物件初始化方法（像是出生設定） constructor 建構子，負責建立物件時的初始化行為 self 指向目前的物件本身 Product.init() 明確呼叫父類別的方法（不推） super().init() 推薦方式，維護性高，更安全 繼承 (完整範例) 1 2 3 4 5 6 7 8 9 class Drink(Product): def __init__(self, name, price, volume): super().__init__(name, price) # 輕鬆繼用 Product 的設定 self.volume = volume # Drink 自己的新屬性 d = Drink(\u0026#39;珍珠奶茶\u0026#39;, 80, 600) # 投入參數 print(d.name) # 珍珠奶茶 print(d.price) # 80 print(d.volume) # 600 常見問題 Q\u0026amp;A Q1: 為什麼要繼承？ A: 繼承可以讓我們重複使用既有的程式碼，避免每個類別都重頭寫一次。比如你定義了一個 Product 類別，之後建立 Drink、Snack 等類別時，就能直接繼承 Product 的屬性與方法，只補上各自特有的部分即可。\nQ2: 一定要用 super() 嗎？ A: 沒有硬性規定，你也可以直接用 Product.__init__(self, name, price)，但 super() 是更推薦的寫法，特別是後續有多重繼承時會更簡潔。\nQ3: 子類別可以新增自己的方法嗎？ A: 當然可以！你可以在 Drink 裡加上任何想加的方法或屬性。\nQ4: 如果子類別沒有寫 __init__ 會怎樣？ A: Python 會自動使用父類別的 __init__()，不會報錯，只是就無法加入子類別自己的新屬性了 # (1)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Product: def __init__(self, name, price): self.name = name self.price = price # (1)子類別沒有寫 __init__() class Snack(Product): pass s1 = Snack(\u0026#34;洋芋片\u0026#34;, 50) print(s.name) # 洋芋片 print(s.price) # 50 # (2)子類別有寫 __init__() class Snack(Product): def __init__(self, name, price, flavor): super().__init__(name, price) self.flavor = flavor # 可以加上新屬性 s2 = Snack(\u0026#34;洋芋片\u0026#34;, 50, \u0026#34;鹽味\u0026#34;) print(s.name) # 洋芋片 print(s.price) # 50 print(s.flavor) # 鹽味 Q5: 可以繼承多個父類別嗎？ A: 可以，Python 支援 多重繼承，例如：class A(B, C)，但建議初學者先從單一繼承開始學起。\n🤔 腦力激盪 如果你要寫一個 Student 類別，你會繼承 Person 還是 Teenager？為什麼？\n(參考答案)\n初階想法： 我會繼承 Teenager，因為大多數學生是青少年，而 Teenager 裡的屬性像「打工」或「升學壓力」也適用，直接用比較方便。\n進階想法： 如果我的 Student 類別要包含國小、國中、高中、研究所，那就不適合只繼承 Teenager，應該回頭繼承 Person，再自己定義年齡區段或學級屬性。\n感謝閱讀這篇簡單實用的繼承入門指南，希望你有更熟悉 class 的應用！~\n","date":"2025-05-25T11:00:00Z","image":"https://michellellehcim.github.io/p/python-inheritance-guide2/python_inheritance_hu3316487914109495946.png","permalink":"https://michellellehcim.github.io/p/python-inheritance-guide2/","title":"Python OOP入門指南 (一) ：繼承"},{"content":"在學 Python 類別的時候，你可能會遇到這樣的寫法：\n1 2 3 4 class MathTool: @staticmethod def add(x, y): return x + y 咦？這段程式碼怎麼沒有 self 或 cls 呢？這就是 靜態方法（static method） 的特色。\n什麼是 static method？ @staticmethod 是一種定義在「類別中」但 不需要依賴實例或類別本身 的方法。\n簡單說：「它只是剛好寫在 class 裡的普通函式」。\n一般方法 vs staticmethod 1 2 3 4 5 6 7 class Dog: def bark(self): # 一般方法（會自動接收 self 參數） print(\u0026#34;汪\u0026#34;) dog = Dog() # 建立 Dog 類別的實例 dog.bark() # 汪 (會自動把 dog 當成 self 傳入) Dog.bark() # ❌ TypeError ：少了 self → 呼叫失敗 1 2 3 4 5 6 7 8 9 class Dog: @staticmethod # staticmethod 裝飾器 def greet(): # 靜態方法（不需要 self/cls） print(\u0026#34;Hello!\u0026#34;) Dog.greet() # Hello! dog = Dog() dog.greet() # 也可以（但不推薦，會讓人以為與物件有關） 方法類型 是否自動傳入參數 第一個參數 呼叫方式 一般方法 ✅ 是 self dog.bark() 靜態方法 ❌ 否 無 Dog.greet() or dog.greet() 範例：工具類別中的靜態方法 1 2 3 4 5 6 class MathTool: #定義一個類別 MathTool，用來裝一些數學相關的工具方法。 @staticmethod # 靜態方法裝飾器 def add(x, y): #接收兩個引數，不需 self return x + y # 呼叫靜態方法（類別名.方法名），不需要先建立物件 print(MathTool.add(5, 7)) # 類別直接呼叫，輸出 12 為什麼要這樣用？ 因為 add(x, y) 跟這個類別沒有關聯，它只是個通用的小工具。\n什麼時候該用 staticmethod？ 使用 @staticmethod 的時機：\n方法邏輯不需要使用實例資料（self） 方法邏輯不需要使用類別屬性（cls） 只是單純提供工具功能（像 加法、格式轉換） ❌ 常見錯誤與誤解 沒加 @staticmethod 就直接寫\n1 2 3 class Tool: def convert(): # ❌ 會錯：缺 self pass 正確寫法應該是：\n1 2 3 @staticmethod def convert(): pass 新手常見 Q\u0026amp;A Q1：staticmethod 和 classmethod 有什麼不同？ 裝飾器 傳入參數 用途 @staticmethod 無 完全獨立的工具方法 @classmethod cls 要操作「類別本身」的資料 Q2：為什麼不直接把函式寫在 class 外面？ 你可以！不過放在 class 裡面可以：\n表示這是「這個類別的功能」 對讀者來說更組織清楚 Q3：static method 可以用物件呼叫嗎？ 可以，但沒意義。\n1 2 m = MathTool() print(m.add(2, 3)) # ✅ 可以，但建議直接 MathTool.add(...) 🧩 小挑戰：來試試看！ 請你自己動手寫一個類別 TextUtils，裡面有一個 @staticmethod 方法 word_count(text)，可以計算一段文字的單字數量。\n1 print(TextUtils.word_count(\u0026#34;hello world! this is python.\u0026#34;)) # 應該輸出：5 總結 問題 說明 static method 是什麼？ 不需要 self/cls 的類別方法 怎麼寫？ 用 @staticmethod 裝飾器 什麼時候用？ 當你寫的是跟類別/實例無關的功能 有什麼好處？ 更清楚的程式組織、更好維護 💬 腦力激盪：你覺得以下哪個方法最適合用 @staticmethod？ A. 計算一個帳戶的利息\nB. 驗證輸入的 email 格式\nC. 取得目前登入使用者的資訊\n(解答)\n選項 說明 A. 計算帳戶利息 通常需要用到帳戶的餘額等「實例資料」，應使用一般方法（self） B. 驗證 email 格式 ✅ 純邏輯判斷，不依賴實例或類別屬性，很典型的工具方法 C. 取得登入使用者資訊 可能需從 session 或系統狀態中取資料，通常會用 class method 或其他機制 💡 延伸小範例\n1 2 3 4 5 6 class Validator: @staticmethod def is_valid_email(email): return \u0026#34;@\u0026#34; in email and \u0026#34;.\u0026#34; in email print(Validator.is_valid_email(\u0026#34;test@example.com\u0026#34;)) # True 太棒了!!恭喜你已經學會了一種裝飾器的用法。\n","date":"2025-05-01T10:00:00+08:00","image":"https://michellellehcim.github.io/p/python-staticmethod-guide/python_staticmethod_guide_hu17525991268467789733.png","permalink":"https://michellellehcim.github.io/p/python-staticmethod-guide/","title":"Python 靜態方法（@staticmethod）新手教學：什麼時候該用？"},{"content":"什麼是迭代 (Iteration)? Python 新手必看的入門教學 想了解 Python 的 for 迴圈是怎麼運作的嗎？\n這篇文章將帶你從最基礎開始，一步步搞懂 Python 中的 迭代（Iteration），以及你一定會看到的兩個角色：可迭代物件（iterable） 和 迭代器（iterator）。\n什麼是迭代（Iteration） 迭代，是按照順序一個一個取出資料的過程。\n例如：\n1 2 for i in \u0026#34;Michelle\u0026#34;: print(i) 會印出：\nM i c h e l l e\n什麼是可迭代物件（iterable） 可迭代物件是指「可以被 for 迴圈處理」的資料。也就是說，裡面的元素可以被一個一個取出來。\n以下是幾種常見的可迭代物件，每種都附上一個例子：\n字串（string）\n1 2 for i in \u0026#34;hello\u0026#34;: print(i) 清單（list）\n1 2 for i in [1, 2, 3]: print(i) 元組（tuple）\n1 2 for i in (4, 5, 6): print(i) 字典（dict）\n1 2 for key in {\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2}: print(key) 集合（set）\n1 2 for i in {7, 8, 9}: print(i) range 物件\n1 2 for i in range(3): print(i) 什麼是迭代器（iterator） 迭代器是真正執行「逐一取值」動作的東西，它會記住目前走到哪裡。\n可以用內建函式 iter() 將一個可迭代物件變成迭代器：\n1 2 x = [1, 2, 3] it = iter(x) 接著用 next() 一個一個取值：\n1 2 3 4 print(next(it)) # 1 print(next(it)) # 2 print(next(it)) # 3 print(next(it)) # 會發生 StopIteration 錯誤 說明：\n迭代器有記憶功能，知道自己目前位置 走過的內容不能回頭，只能從頭到尾走一遍 迭代只能走一次 這是新手最容易忽略的地方\n1 2 3 4 5 x = [1, 2, 3] it = iter(x) print(list(it)) # [1, 2, 3] print(list(it)) # [] 因為 it 是迭代器，已經走完了，後面就沒有資料可以用了。\n同樣地：\n1 2 3 4 5 x = [1, 2, 3] it = iter(x) print(sum(it)) # 6 print(sum(it)) # 0 range(0) 是空的迭代 1 2 for i in range(0): print(\u0026#34;hi\u0026#34;) 不會印出任何東西，因為 range 裡沒有任何數字。\n新手常見問題整理 1. 為什麼 list(it) 第二次是空的？ 因為迭代器只能走一次，已經被取光了。要重新取值就要重新呼叫 iter。\n2. 我可以直接對 list 用 next() 嗎？ 不行，list 本身不是迭代器，要先用 iter(list) 才能用 next。\n3. 什麼時候需要自己用 iter() 和 next()？ 當你需要更細緻地控制資料的讀取過程，例如寫 parser、處理大型檔案、觀察迭代行為時。\n4. 什麼時候會使用 iterator？ 當你需要逐步取出資料並保持當前狀態時會用到 iterator，例如你想中斷再繼續迭代、或要自己控制流程時。\n5. 可迭代物件和迭代器有什麼不同？ 可迭代物件是「可以被疊代的資料容器」，但本身不能用 next 取值 迭代器是用 iter() 從可迭代物件產生的物件，才可以用 next() 小挑戰：這段程式會輸出什麼？ 1 2 3 4 5 x = [10, 20, 30] it = iter(x) print(next(it)) print(sum(it)) 正確答案是：\n10 50\n說明：\n第一次 next(it) 取出 10 剩下的是 [20, 30]，所以 sum(it) 為 50 你答對了嗎？\n","date":"2024-11-30T10:00:00Z","image":"https://michellellehcim.github.io/p/python-iterator/python_iterator_hu8374197008918847623.png","permalink":"https://michellellehcim.github.io/p/python-iterator/","title":"Python 可迭代 (Iteratable) 與 迭代器 (Iterator) 入門"},{"content":"Python 字串格式化入門教學 你是否曾經遇到要在 print() 中顯示變數內容，但不知道該怎麼優雅地寫出整齊又清楚的訊息？\n本篇將帶你一步一步認識 Python 的 三種字串格式化方式：\n((第1和第2種可以看過稍微了解概念就好，覺得麻煩的話可以直接看第3點的 f-string XD))\n% 格式化 (舊式) str.format() 格式化 (新式) Python 3.6+ 的 f-string（最推薦!!新手請直接學） 1️⃣ 舊式格式化：% 操作符 這是 Python 最早期的格式化方式，很像 C 語言中的 printf。\n1 2 3 4 5 6 7 8 name = \u0026#39;World\u0026#39; x = 100 y = 3.1415 print(\u0026#39;hi %s\u0026#39; % name) # hi Wolrd print(\u0026#39;hi %d\u0026#39; % x) # hi 100 print(\u0026#39;hi %f\u0026#39; % y) # hi 3.141500 print(\u0026#39;hi %s, my number is %d\u0026#39; % (name, x)) # hi World, my number is 100 ✅ 格式說明： 符號 代表意思 範例 %s 字串 'World' %d 整數（decimal） 100 %f 浮點數 3.14 你也可以控制小數點位數：\n1 print(\u0026#39;pi = %.2f\u0026#39; % 3.14159) # pi = 3.14 2️⃣ str.format() 方法（新式） 這種寫法較有彈性，也更容易閱讀和管理。\n1 2 print(\u0026#39;hi {}, my number is {}\u0026#39;.format(name, x)) # hi World, my number is 100 也可以加入欄位索引或變數名稱：\n1 2 print(\u0026#39;hi {0}, my number is {1}\u0026#39;.format(name, x)) print(\u0026#39;hi {name}, number: {num}\u0026#39;.format(name=name, num=x)) 3️⃣ f-string（Python 3.6+ 最推薦） f-string 是目前最推薦的格式化方式，簡潔、直觀、可讀性高。\n1 2 print(f\u0026#39;hi {name}, my number is {x}\u0026#39;) # hi World, my number is 100 print(f\u0026#39;y = {y:.2f}\u0026#39;) # y = 3.14 f-string 補充：對齊與寬度設定 你可以使用 f-string 的語法來控制欄位的寬度與對齊方式。\n1 2 3 4 5 name = \u0026#34;World\u0026#34; x = 100 # 將 name 往右對齊，寬度為 10 個字元 print(f\u0026#39;hi {name:\u0026gt;10}, my num is {x}\u0026#39;) 輸出結果：\n1 hi World, my num is 100 對齊格式一覽： 語法 說明 :\u0026gt;10 右對齊，寬度 10 :\u0026lt;10 左對齊，寬度 10 :^10 置中對齊，寬度 10 :*^10 置中並用 * 補滿 1 2 3 print(f\u0026#39;|{name:\u0026lt;10}|\u0026#39;) # |World | print(f\u0026#39;|{name:^10}|\u0026#39;) # | World | print(f\u0026#39;|{name:*^10}|\u0026#39;) # |**World**| 三種格式化方式比較 類型 語法風格 可讀性 推薦程度 舊式 % 'hi %s' % name 中 ❌ 不推薦 .format() 'hi {}'.format() 中上 ☑️ 可用 f-string f'hi {name}' 高 ✅✅✅✅✅ 總結 | 如果你使用的是 Python 3.6+，強烈建議直接使用 f-string，簡單又強大！\n| 如果還在學舊專案或 C 語言背景的人，可以理解 % 是歷史包袱，但新專案建議避免使用。\n小練習 試著完成以下程式碼，輸出你的名字與分數（保留小數點後 1 位）：\n1 2 3 4 name = \u0026#39;你的名字\u0026#39; score = 97.567 # 請用 f-string 輸出：Hi, 我是 你的名字，我的成績是 97.6 分 ","date":"2024-11-29T10:00:00Z","image":"https://michellellehcim.github.io/p/python-fstring/python_f-string_hu10959145997654789697.png","permalink":"https://michellellehcim.github.io/p/python-fstring/","title":"Python 字串格式化入門：從 `%` 到 `f-string` 一次搞懂"},{"content":"Python 註解與 Docstring 新手教學指南 在寫程式的過程中，「讓別人（包括未來的自己）看得懂」比你想得還重要！\n學會 註解（comment） 和 說明文件（docstring） 是寫出可讀、可維護程式碼的第一步。\n什麼是註解（Comment）？ 註解是 不會被 Python 執行 的文字，通常用來解釋程式邏輯、標註重點、提醒未來的自己或團隊。\n寫法語法： 1 2 # 這是一行註解 x = 10 # 註解也可以寫在程式碼後方 快速註解技巧（適用多數編輯器）： Windows / Linux：Ctrl + / macOS：Command + / 什麼是 Docstring（說明文件）？ Docstring 是寫給 函式、類別、模組 的內建文字說明，它不是普通的註解，而是可以被程式存取的說明內容。\n語法： 1 2 3 4 5 def greet(name): \u0026#34;\u0026#34;\u0026#34; 傳入名字並回傳問候語。 \u0026#34;\u0026#34;\u0026#34; return f\u0026#34;Hello, {name}!\u0026#34; 你可以使用三個雙引號 \u0026quot;\u0026quot;\u0026quot; ... \u0026quot;\u0026quot;\u0026quot; 或三個單引號 ''' ... ''' 包住說明。\nComment 與 Docstring 差在哪？ 功能 Comment Docstring 用途 解釋程式邏輯 說明函式 / 類別 / 模組用途 寫法 # 開頭 \u0026quot;\u0026quot;\u0026quot;文字\u0026quot;\u0026quot;\u0026quot; 或 '''文字''' 位置 任意 僅能放在定義之後 是否可透過程式存取 ❌ 否 ✅ 可用 help() 或 .__doc__ 使用 Docstring 的好處 可用 help() 查詢說明 自動生成 API 文件 團隊更容易理解彼此的程式碼 範例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def add(a, b): \u0026#34;\u0026#34;\u0026#34; 回傳 a + b 的結果。 參數: a (int or float): 數值1 b (int or float): 數值2 回傳: 整數或浮點數 \u0026#34;\u0026#34;\u0026#34; return a + b print(add.__doc__) help(add) 🧑‍🏫 Docstring 標準寫法建議（推薦） 可以參考 Google Python Style Guide，以下是建議格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def divide(x, y): \u0026#34;\u0026#34;\u0026#34; 回傳 x 除以 y 的結果。 參數: x (float): 被除數 y (float): 除數，不能為 0 回傳: float: 商數結果 範例: \u0026gt;\u0026gt;\u0026gt; divide(10, 2) 5.0 \u0026#34;\u0026#34;\u0026#34; return x / y Docstring 也能用在類別中！ 1 2 3 4 5 6 7 8 9 class Animal: \u0026#34;\u0026#34;\u0026#34; 動物基礎類別，定義所有動物的共用邏輯。 \u0026#34;\u0026#34;\u0026#34; def __init__(self, name): self.name = name a = Animal(\u0026#34;Dog\u0026#34;) print(Animal.__doc__) 💡 Docstring 撰寫小技巧 技巧 說明 ✅ 放在定義後的第一行 否則不會被辨識為 docstring ✅ 使用完整句子 可幫助他人快速理解功能用途 ✅ 可搭配 IDE 自動補全 好維護又易閱讀 ❌ 不要寫成純註解 # 開頭不會被當作 docstring 互動式小測驗！你掌握了嗎？ 1️⃣ 以下哪個是合法的 Python 註解？\n1 2 3 # 這是註解 // 這是 C 語言註解？ /* 這是 Java 的寫法？ */ 2️⃣ Docstring 一定只能使用 \u0026quot;\u0026quot;\u0026quot; 嗎？可以用什麼取代？\n3️⃣ 如何查詢某個函式的 docstring 說明？\n4️⃣ 請用 Docstring 寫一個 say_hi(name) 函式的說明。\n小結 工具 用途 # 註解，說明程式邏輯 \u0026quot;\u0026quot;\u0026quot;...\u0026quot;\u0026quot;\u0026quot; docstring，說明函式或類別用途 help(obj) 查詢對象的 docstring . __doc__ 直接取得 docstring 字串 腦力激盪 你在寫程式時有習慣加上註解或 docstring 嗎？你認為它們在團隊合作或未來維護上能發揮什麼效果呢？歡迎留言一起討論～\n","date":"2024-11-28T10:00:00Z","image":"https://michellellehcim.github.io/p/python-comment-docstring-guide/python_comment_docstring_hu15384211257858402893.png","permalink":"https://michellellehcim.github.io/p/python-comment-docstring-guide/","title":"Python 註解與 Docstring 新手入門指南：寫出有說明的程式"},{"content":"⚙️ Python 底線用法全解析 你是否曾經看過 Python 程式碼中滿是底線的命名方式，像是 __init__、_name 或 for _ in range()？\n這些底線並不是隨便寫的，而是有約定俗成的「潛規則」，讓你能更清楚地表達變數或函式的用途與作用範圍。\n目錄 1️⃣ _：單底線（暫時、不重要的變數） 2️⃣ _name：單底線開頭（弱私有屬性） 3️⃣ name_：單底線結尾（避開保留字） 4️⃣ __name：雙底線開頭（名稱改寫（name mangling）） 5️⃣ __name__：雙底線包夾（魔術方法（magic method）） ❓ 常見問題 Q1：_ 可以被當作變數名嗎？ Q2：我在類別裡寫 _變數，就真的變私有了嗎？ Q3：可以自己定義 __myfunc__() 嗎？ 1️⃣ _：單底線（暫時、不重要的變數） ✅ 用法：用在不需要用到的變數上，代表「我不在乎這個值」。 1 2 for _ in range(5): print(\u0026#34;Hello\u0026#34;) # 印出 5 次 這裡的 _ 只是個「佔位符」，不會真的被使用。\n⚠ 注意： _ 雖然可以用來存上一個結果（例如 REPL 模式下），但一般不要重複用 _ 存資料，會讓程式難以維護。\n2️⃣ _name：單底線開頭（弱私有屬性） ✅ 用法：這是一種 命名慣例（naming convention），表示「這是內部用的，請不要在類別外部使用」。 1 2 3 4 5 6 class Person: def __init__(self): self._age = 30 # 弱私有 p = Person() print(p._age) # 雖然可以存取，但通常建議不要 並不是真正的私有（private），只是提醒其他開發者「請小心使用」。 如果在模組中用 from module import *，開頭為 _ 的函式/變數 不會被匯入。 3️⃣ name_：單底線結尾（避開保留字） ✅ 用法：當變數名稱與 Python 保留字（keyword）衝突時，可以在後面加底線。 1 class_ = \u0026#34;Math\u0026#34; # 因為 class 是保留字 也常見於解構時命名變數避免衝突。\n4️⃣ __name：雙底線開頭（名稱改寫 / name mangling） ✅ 用法： 這是 Python 提供的「名稱改寫機制（Name Mangling）」，目的是避免子類別不小心覆寫到父類別的內部變數或方法名稱。\n當你使用雙底線開頭命名（例如 __type），Python 會自動幫它重新命名為 _類別名稱__變數名 的格式，這樣即使在子類別中出現同名變數，也不會互相干擾。\n1 2 3 4 5 6 7 class Animal: def __init__(self): self.__type = \u0026#34;mammal\u0026#34; a = Animal() print(a.__type) # ❌ AttributeError: \u0026#39;Animal\u0026#39; object has no attribute \u0026#39;__type\u0026#39; print(a._Animal__type) # ✅ OK，實際上變數被重新命名成 _Animal__type 🧠 為什麼 __type 不行？ 當我們寫 self.__type 時，Python 在背後其實會把它改名為 self._Animal__type。這是為了保護變數不被外部或子類誤用或覆蓋。\n所以：\n__type 直接取值就會報錯，因為這個名字根本不存在於物件的屬性列表中。 正確的變數名已經被改成了 _Animal__type (可以透過印出 dir(a) 來查看)。也就是說，它其實是存到 self._Animal__type 這個變數裡，而不是 self.__type。 📌 小提醒： 在 Python 中，此改名並非真正的私有保護，它只是讓存取更困難一點。 請避免濫用這個機制，通常只有在你寫大型專案、需要確保屬性不會被子類或外部干擾時才會使用。 5️⃣ __name__：雙底線包夾 / Dunder method （或是叫做魔術方法 / magic method） ✅ 用法： 這是 Python 特有的語法設計，是預留給內建功能或是魔術方法使用的。\n常見例子包括：\n1 2 3 4 5 def __init__(self): # 建構子（constructor） pass def __str__(self): # 轉為字串 pass 這些方法都有特殊用途，不建議自創這類命名。 最常見的例子是模組入口判斷： 1 2 if __name__ == \u0026#34;__main__\u0026#34;: main() 代表此檔案被「直接執行」而非被匯入。\n❓ 常見問題 Q1：_ 可以被當作變數名嗎？ A：可以，但不建議長時間使用，容易混淆。\nQ2：我在類別裡寫 _變數，就真的變私有了嗎？ A：不是真的私有，只是開發者之間的約定俗成。\nQ3：可以自己定義 __myfunc__() 嗎？ A：可以，但不建議。__xxx__ 是給 Python 保留的，請避免自己創造。\n💬 你最常用哪種底線寫法？ 你在開發時最常遇到哪一種底線命名方式呢？\n歡迎留言分享你的使用情境，或是你曾經踩過的坑 🕳️！\n","date":"2024-11-24T10:00:00Z","image":"https://michellellehcim.github.io/p/python-underscore/python_underscore_hu11171120152085451877.png","permalink":"https://michellellehcim.github.io/p/python-underscore/","title":"Python 底線用法全解析：從命名慣例到魔術方法"},{"content":"🌐 網站是怎麼運作的？ 你有沒有好奇過，當我們打開一個網站的時候，背後到底發生了什麼？今天，我們來聊聊網站的運作方式，以及如何建立一個購物網站的前端和後端架構。\n🖥️ 前端和後端：誰負責什麼？ 一個網站通常分為兩個主要部分：\n🎨 前端（Front-end）：使用者看到的部分，包括畫面、按鈕、文字和圖片。它負責和使用者互動，內容會在瀏覽器中運行。 🔧 後端（Back-end）：藏在幕後的部分，運行在伺服器上，負責處理資料、驗證規則，並確保前端取得正確資訊。 🌍 使用者訪問網站時發生了什麼？ 假設使用者 Jenny 想逛我們的購物網站，她在瀏覽器輸入 goodbuy.com，然後按下 Enter。這時：\n瀏覽器會發送一個請求，類似說：「嗨~~我想看看首頁！」\n伺服器收到後會處理這個請求，然後回傳結果給瀏覽器。這一來一回的過程是透過 HTTP（🔗 Hypertext Transfer Protocol） 完成的，這是一種讓瀏覽器和伺服器溝通的語言。\n(註) goodbuy.com是URL（🌐 Uniform Resource Locator） 等於是網站的地址，幫助 Jenny 的瀏覽器找到伺服器。\n⚙️ 後端如何提供內容？ 當伺服器收到請求後，有兩種方式回應：\n📄 生成完整的網頁並回傳：\n伺服器會使用 HTML（超文本標記語言） 建立完整的網頁，然後傳送給使用者。 📊 只提供所需數據，讓前端生成頁面：\n伺服器只傳回資料（例如產品清單），由前端工具（如 React）生成畫面。 🤔 選擇第二種方式的好處: 減輕伺服器壓力：伺服器只專注處理數據，能夠服務更多使用者。 擴展性更好：隨著用戶數量增加，伺服器的負擔也更容易管理。 這也是為什麼現在越來越多網站使用 React、Angular 和 Vue 來處理前端。\n🛠️ 後端的角色：資料的管家 如果把頁面生成交給前端，那後端的主要任務就是管理數據，並提供 API（應用程式介面，Application Programming Interface）。\n🎛️ API 是什麼？ API 就像遙控器上的按鈕：\n每個按鈕都有特定功能，比如開關電視或調整音量。 同樣，API 是伺服器提供的「按鈕」，讓前端用來取得產品資料或提交訂單。 🐍 用 Django 建立 API 在後端世界裡，Django 是一個非常受歡迎的框架，能快速幫助我們建立 API：\nDjango 讓處理數據和提供接口變得更簡單高效。 前端應用（例如使用 React 或 Angular 開發的網站）可以透過 API 與後端互動，完成查詢產品或提交訂單的功能。 🏁 結論 現代網站開發強調分工合作：\n🎨 前端 負責生成畫面，提升使用者體驗。 🔧 後端 專注處理數據和業務邏輯，提供高效的 API。 如果你想建立一個高效的網站，像 Django 這樣的後端框架絕對是值得考慮的好選擇！希望這次的分享讓你對網站的運作有更清楚的了解！ 🚀\n","date":"2024-10-18T10:00:00Z","image":"https://michellellehcim.github.io/p/web-work/web_work_hu900111646212904461.png","permalink":"https://michellellehcim.github.io/p/web-work/","title":"網站是怎麼運作的？"},{"content":"Django 是目前最受歡迎的 Web 框架之一，許多企業，包括 Instagram、Spotify、Dropbox、Pinterest 等，都選擇 Django 作為開發後端的主要技術。為什麼 Django 受到企業青睞？本文將從 開發效率、安全性、可擴展性、社群支持 等方面分析 Django 的優勢。\n1. 開發效率高 Django 遵循 \u0026ldquo;Batteries Included\u0026rdquo;（電池全配） 原則，內建許多強大的功能，減少開發者從零開始設計系統的時間。\n✅ 內建功能 ORM（Object-Relational Mapping）：讓開發者用 Python 直接操作資料庫，避免手寫 SQL。 身份驗證（Auth System）：內建用戶管理系統，處理登入、註冊、權限控管。 Admin Panel（管理後台）：自動生成管理介面，方便管理數據。 表單處理（Forms）：內建表單驗證與數據處理，提高開發效率。 ✅ 快速開發 MVP Django 幫助企業快速建立 最小可行產品（MVP），適合新創公司測試市場需求，降低開發成本。\n2. 高安全性 Django 內建多種安全機制，幫助企業降低安全風險，避免常見的 Web 攻擊。\n🔒 內建安全防護 SQL Injection 防護：ORM 自動處理 SQL 查詢，避免 SQL 注入攻擊。 CSRF（跨站請求偽造）防護：防止未經授權的請求。 XSS（跨站腳本攻擊）防護：自動轉義 HTML，防止惡意腳本執行。 密碼加密存儲：使用 PBKDF2、Argon2、BCrypt 等強大加密算法。 對於處理敏感數據的企業（如金融、醫療、電子商務），Django 是一個值得信賴的選擇。\n3. 可擴展性強 Django 適用於 從小型應用到大型系統，隨著業務成長，可以輕鬆擴展。\n📈 企業級擴展能力 支援快取（Caching）：Redis、Memcached 讓 Django 快速處理大量請求。 可水平擴展：支援負載均衡，可擴展到多台伺服器。 支援 Microservices：透過 Django REST Framework（DRF），可輕鬆開發 API 服務，適合微服務架構。 許多大型應用，如 Instagram、Disqus、Mozilla，都用 Django 來處理大規模流量。\n4. 強大的社群與企業支持 Django 由 Django Software Foundation（DSF） 維護，擁有活躍的開源社群和大量第三方套件。\n🌍 企業與開發者社群 開發者眾多：Python 是全球最受歡迎的語言之一，學習 Django 門檻低。 第三方擴展豐富：如 Django REST Framework（DRF）、Celery（背景任務）、Channels（即時應用）。 免費與開源：Django 採用 BSD 授權，企業可自由使用，無需支付授權費。 這些優勢讓 Django 成為企業開發的首選之一。\n5. 與 Python 生態系統無縫整合 Python 是 AI、機器學習、數據分析 領域的熱門語言，而 Django 可以輕鬆與這些技術結合。\n🤖 AI / 數據應用 Django + Pandas / NumPy：適合數據分析應用。 Django + TensorFlow / PyTorch：可開發 AI 應用。 Django + Celery：用於處理大規模數據、排程任務。 對於 AI 驅動的企業，如 Netflix、Spotify，Django 是理想的選擇。\n🔥 結論：Django 為何受企業歡迎？ 企業需求 Django 解決方案 快速開發 內建 ORM、Auth、Admin Panel，提高開發效率 高安全性 內建 CSRF、XSS、SQL Injection 防護 可擴展性 支援快取、負載均衡、微服務架構 AI / 數據應用 與 Python 生態整合，適合數據驅動企業 社群與企業支持 開源、免費、大量第三方套件支援 綜合來看，Django 具備 高效、安全、可擴展 的特性，能夠滿足企業從小型應用到大型系統的需求，因此成為許多企業的首選 Web 框架！🚀\n📌 你使用過 Django 嗎？歡迎留言分享你的開發經驗！\n","date":"2024-10-16T20:00:00Z","image":"https://michellellehcim.github.io/p/django-intro/django_intro_hu1015426287199860554.png","permalink":"https://michellellehcim.github.io/p/django-intro/","title":"為什麼Youtube、instagrm等知名企業愛用 Django？"},{"content":"什麼是 Node.js？ 簡單來說，Node.js 是一個讓你在電腦上執行 JavaScript 程式的工具。這跟你在網頁瀏覽器上看到的 JavaScript 不太一樣，因為它可以直接運行在電腦上，而不需要透過瀏覽器。\n但它的用途遠不止於此~ 它讓 JavaScript 不再只限於瀏覽器內運行，而能用來開發功能強大的應用程式，例如伺服器、API 服務、工具應用等。\nNode.js 的優點 非同步與事件驅動架構 (Asynchronous and Event-Driven)：讓伺服器可以同時處理多個請求。 JavaScript 友好 (JavaScript-Friendly)：如果你有點 JavaScript 基礎，在學習 Node.js 上會更上手! 豐富的模組庫 (Rich Module Library, npm)：可以使用數十萬個免費模組，現成的工具能幫你快速完成專案。 可以用 Node.js 做什麼？ 建立後端伺服器 (Build Backend Servers)\n透過 Node.js，你可以快速建立一個處理用戶請求的伺服器，像是處理資料上傳、提供網頁內容，甚至管理使用者帳號。\n即時應用 (Real-Time Applications)\n開發聊天系統、即時遊戲或即時通知等需要快速資料更新的應用程式。例如，你可以用 Node.js 開發一個多人聊天室。\n搭建 API (Build APIs)\nNode.js 常被用來構建 REST API 或 GraphQL API，這樣你的前端應用程式或其他服務可以和後端資料庫溝通。\n處理資料 (Handle Data)\n使用 Node.js，可以讀寫檔案、操作資料庫，甚至處理大量的資料流，像是處理影片或音訊檔案。\n自動化工具 (Automation Tools)\n你可以用 Node.js 寫腳本，幫助你完成一些繁瑣的工作，比如檔案壓縮、圖片批次處理或自動測試程式碼。\n構建桌面應用 (Build Desktop Applications)\n結合框架如 Electron，你可以用 Node.js 開發跨平台的桌面應用程式，例如 Visual Studio Code 就是用 Node.js 製作的。\n打造高效能網站 (Create High-Performance Websites)\nNode.js 能讓你建造能快速處理大量請求的網站，特別適合處理高流量的應用，例如購物網站或媒體平台。\n物聯網開發 (IoT Development)\n結合硬體裝置，Node.js 可用於開發 IoT 應用程式，像是連接智能設備並處理資料。\n怎麼用 Node.js？ 官網上的示範很簡單，以下是大致步驟：\n下載 Node.js（選擇 LTS）\n到 Node.js 官網 下載並安裝 LTS 版本。\n檢查安裝是否成功\n打開終端機（Terminal 或命令提示字元），輸入以下指令：\n1 node -v 如果顯示版本號（例如 v20.18.0），表示安裝成功！\n執行一段 JavaScript 程式\n輸入:\n1 node 按下Enter, 然後繼續輸入以下程式碼:\n1 console.log(\u0026#39;Hello, Node.js!\u0026#39;); 按下Enter會看到程式輸出結果。\n還可以按照官網步驟建立一個簡單的伺服器\n1 2 3 4 5 6 7 8 9 10 import { createServer } from \u0026#39;node:http\u0026#39;; //建立伺服器 const server = createServer((req, res) =\u0026gt; { res.writeHead(200, { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain\u0026#39; }); res.end(\u0026#39;Welcome to Node.js Server!\\n\u0026#39;); }); // 伺服器在http://127.0.0.1:3000監聽 server.listen(3000, \u0026#39;127.0.0.1\u0026#39;, () =\u0026gt; { console.log(\u0026#39;伺服器運行中：http://127.0.0.1:3000/\u0026#39;); }); 將以上程式碼存為server.mjs （檔名的副檔名 .mjs 是 Node.js 的 ES Module 格式），然後在終端機執行\n1 node server.mjs 執行後，終端機會出現以下訊息，表示伺服器已經成功啟動:\n伺服器運行中：http://127.0.0.1:3000/\n打開就能看到訊息：Welcome to Node.js Server!\n如果想停止伺服器，回到終端機，按下 Ctrl + C\n這樣你就已經完成了一個簡單的HTTP伺服器了，當你在瀏覽器訪問http://127.0.0.1:3000時，伺服器會接到一個HTTP請求(request)。\n它會回應(response)一段文字: Welcom to Node.js Server!\n\u0026lt;示範\u0026gt; 我用VS Code編輯器 總結 Node.js 是一個強大又靈活的工具，不僅適合建立伺服器，還能用來開發各種應用程式。無論你是新手還是有經驗的開發者，Node.js 都能幫助你快速開發功能，讓網站和應用程式的效能更上一層樓！\n","date":"2024-10-15T20:00:00Z","image":"https://michellellehcim.github.io/p/node-js-intro/node_js_hu11759947230538510114.png","permalink":"https://michellellehcim.github.io/p/node-js-intro/","title":"網站為什麼這麼快？原來是因為 Node.js！"},{"content":" 先到HackMD https://hackmd.io/ 註冊一個帳號, 登入後左上角直接點選 + Create note 就可以開始寫筆記了 ~\n以下是我整理的常用MD語法:\n1. 標題 (Heading) : 使用 # 符號來表示標題層級 # 標題一\n## 標題二\n### 標題三\n#### 標題四\n##### 標題五\n###### 標題六\n標題一 標題二 標題三 標題四 標題五 標題六 2. 粗體字: 文字的前後都加上** 這是**粗體文字**\n這是 粗體文字\n3. 斜體字: 文字的前後都加上* 這是*斜體文字*\n這是斜體文字\n4. 刪除線: 文字的前後都加上~~ 這是~~刪除線~~\n這是刪除線\n5. 無序清單: 項目前面使用 - 或 + 或 * 作為開頭 - 項目 1 - 項目 2 * 項目 3 * 項目 4 + 項目 5 + 項目 6 會自動縮排 \u0026amp; 分段如下:\n項目 1 項目 2 項目 3 項目 4 項目 5 項目 6 ６. 有序清單: 項目前面直接使用 數字+.作為開頭 1. 項目 1 2. 項目 2\n會自動縮排如下:\n項目 1 項目 2 7. 超連結: 語法[文字](網址) [Google](https://www.google.com)\n會變成:\nGoogle\n8. 圖片: 語法 ![替代文字](圖片網址) ![Markdown Logo](https://markdown-here.com/img/icon256.png)\r會變成:\n9. 分隔線: 輸入--- 或 *** (一定要連續輸入3個或3個以上才有效) --- (或 ***)\n會變成:\n10. 引用: 語法 \u0026gt; 文字 \u0026gt; 學程式好好玩\n會變成:\n學程式好好玩\n11. 程式碼(單行): 程式碼前後加上` (需要注意: ` 是在鍵盤最左上角, 和波浪 ~ 是同個鍵)\n`console.log(\u0026lsquo;Hello, world!\u0026rsquo;) `\n會變成:\nconsole.log('Hello, world!')\n12. 程式碼(多行): 程式碼前後加上``` 可以指定要哪一種程式語言，例如javascript\n1 2 3 4 5 ```javascript function sayHello() { console.log(\u0026#39;Hello, world!\u0026#39;); } ``` 會變成:\n1 2 3 function sayHello() { console.log(\u0026#39;Hello, world!\u0026#39;); } 13. 表格: 使用 | 和 - 建立表格 | 標題 1 | 標題 2 |\r|----------|----------|\r| 內容 1 | 內容 2 |\r| 內容 3 | 內容 4 |\r會變成以下:\n標題 1 標題 2 內容 1 內容 2 內容 3 內容 4 14. 任務清單: 語法 - , [] 或 [x] - [x] 已完成項目\r- [ ] 未完成項目\r會顯示:\n已完成項目 未完成項目 恭喜你已經學會基礎Markdown語法，是不是很簡單呢~\n","date":"2024-10-15T18:00:00Z","image":"https://michellellehcim.github.io/p/intro-markdown-basic/markdown%E8%AA%9E%E6%B3%95_%E5%85%A5%E9%96%80%E7%AF%87_hu14648741947410066582.png","permalink":"https://michellellehcim.github.io/p/intro-markdown-basic/","title":"基礎Markdown語法"},{"content":"如果你也正在轉職，非常推薦你也學會用HackMD編輯器!~\n什麼是HackMD呢? HackMD 是一款 即時協作的線上 Markdown 編輯器。\n它讓多人能夠同時在瀏覽器上編輯同一份 Markdown 文件，\n類似 Google Docs 的即時協作功能，但需要建立在 Markdown 語法上。\nHackMD有什麼優點呢? 1. 即時協作 多人可以同時在線上編輯同一份文件，並即時同步更新，避免「你改完後再給我改」的傳統流程。 在多人協作討論需求或整理筆記時，能大幅加速溝通。 2. Markdown 語法支援 Markdown 是輕量級標記語言，對工程師與技術人員而言相對熟悉，簡潔易讀。 HackMD 提供即時預覽，輸入 Markdown 後，右側可同步顯示渲染結果。 3. 方便的整合與分享 和google doc一樣都可以透過共享連結讓其他人閱讀或編輯文件，並且能自訂存取權限（公開、私有或僅限連結存取）。 產出的內容可以輕鬆轉成 HTML、PDF，或直接嵌入專案中。 支援與 GitHub、GitLab、Gist 等整合，讓文件管理與版本控制更輕鬆。 4. 支援簡報模式 HackMD 有內建的簡報功能，可將 Markdown 文件直接轉成簡報格式。 工程師可以用 Markdown 撰寫內容，一鍵切換為簡報模式，省去製作投影片的繁瑣流程。 為什麼許多工程師會喜歡使用HackMD呢? 熟悉的工作模式：Markdown 已在技術社群普及，結合 GitHub、GitLab，能無縫融入程式文件、生產力工具的工作流程。 快速協作：與其他開發者或跨部門同事共同撰寫技術文檔、需求規格，討論和修改同一份文件變得很直覺。 減少版本混亂：不需要再用 email 或多個版本檔案來回傳遞，降低「哪一版才是最新？」的疑慮。 一站式備忘：能直接在 HackMD 撰寫並整理各種筆記、教學文章或專案 Wiki，統一在同一平台中管理。 ","date":"2024-10-15T18:00:00Z","image":"https://michellellehcim.github.io/p/intro-hackmd/hackMD_hu7085793697080894398.jpg","permalink":"https://michellellehcim.github.io/p/intro-hackmd/","title":"工程師為什麼愛用HackMD?"},{"content":"下午終於開始上課了，老師要大家安裝一個平台叫做 \u0026ldquo;Discord\u0026rdquo; , 大家之後就可以在上面討論課程。\nDiscord其實是一個即時訊息和語音通話平台，\n最初是為遊戲玩家設計的，但現在已經擴展到許多不同的社群和團體使用。\n它可以讓用戶創建伺服器（Server），並在這些伺服器內進行語音、文字聊天、文件共享等。\nDiscord的功能： 語音和視訊通話：可進行一對一或群組語音通話、視訊通話。\n文字聊天：可以在不同的頻道中發送訊息、圖片、影片、表情符號等。\n伺服器管理：用戶可以創建、管理伺服器，設置不同的頻道和權限。\n機器人和擴展：可以使用機器人來自動執行某些任務，比如音樂播放、管理伺服器等。\nDiscord v.s. LINE： Discord LINE 用途 適合社群與團隊合作 日常通信，特別是家人、朋友間的聊天 溝通方式 支援伺服器、頻道、語音、直播 一對一、群組聊天、語音和視訊通話 功能 社群管理、機器人、直播等進階功能 文字訊息、語音通話、LINE Pay、貼圖 目標使用者 遊戲玩家、社群、團隊合作 家庭、朋友、同事 平台支持 Windows、Mac、iOS、Android Windows、Mac、iOS、Android 免費與付費 基本免費，付費版提供更多功能 基本免費，部分付費功能（貼圖、LINE Pay） 總的來說呢，Discord 是一個非常適合各種社群活動、團隊合作或娛樂交流的平台。\nDiscord 安裝 https://discord.com/download\n","date":"2024-10-14T18:00:00Z","image":"https://michellellehcim.github.io/p/intro-discord/Discord-Symbol_hu5736111891257977841.webp","permalink":"https://michellellehcim.github.io/p/intro-discord/","title":"什麼是Discord?"},{"content":"第一天開學的上午，課務組發給每人一張九宮格的遊戲單子，單子上面有各種問題，\n例如: 喜歡黑貓還是橘貓? 最喜歡吃什麼? 做過最瘋狂的事情是什麼?\n大家需要離開座位隨機找不同人問這些問題，最後上台介紹你剛剛問了誰，他的回答又是什麼。\n除了單子上的問題，大家也趁機透過聊天了解彼此的背景，\n我才發現班上有各行各業的人才，像是金融業、IC產業、設計師、公家機關、補教機構、高鐵、營養師等等。\n這讓我不禁感嘆，原來我們每個人都擁有著不一樣的經歷和故事，這樣的多元背景不僅讓課堂氣氛更加有趣，也讓我對未來的學習和交流充滿期待。\n這樣的活動不僅讓我們更了解彼此，還讓我深刻體會到每個人的獨特性和他們背後的故事，\n甚至讓我覺得每個人都有自己獨到的視角和經驗，對我的成長也將帶來很多啟發。\n這一天的活動讓我對這個班級產生了更多的興趣，也讓我期待在未來的日子裡，能和大家一起學習、成長，互相激勵，共同進步。\n","date":"2024-10-14T18:00:00Z","image":"https://michellellehcim.github.io/p/day-1/day1_%E8%AA%8D%E8%AD%98%E6%96%B0%E5%90%8C%E5%AD%B8%E5%92%8C%E7%92%B0%E5%A2%83%E5%AE%89%E8%A3%9D_hu11970047249149186396.png","permalink":"https://michellellehcim.github.io/p/day-1/","title":"轉職日記-Day1"}]